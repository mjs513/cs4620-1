package pipeline.vertex;

import java.util.Vector;

import javax.vecmath.Color3f;
import javax.vecmath.Vector2f;
import javax.vecmath.Vector3f;
import javax.vecmath.Vector4f;

import pipeline.Pipeline;
import pipeline.PointLight;
import pipeline.math.Matrix4f;
import pipeline.misc.Vertex;

/**
 * This triangle processor smoothly interpolates the color across the face of
 * the triangle. This is better than flat shading, but still not as nice as
 * fragment (aka phong) shading.
 * 
 * @author ags
 */
public class SmoothShadedVP extends ShadedVP
{
	protected Matrix4f m = new Matrix4f();
	protected Matrix4f modelview = new Matrix4f();
	protected Vector<Vector4f> lightSources;
	protected Vector<Color3f> lightColors;
	
	
	public int nAttr()
	{
		return 3;
	}

	public void updateTransforms(Pipeline pipe)
	{
		modelview.set(pipe.modelviewMatrix);
		
		m.set(pipe.modelviewMatrix);
		m.leftCompose(pipe.projectionMatrix);
		m.leftCompose(pipe.viewportMatrix);
	}

	public void updateLightModel(Pipeline pipe)
	{
		lightSources = new Vector<Vector4f>();
		lightColors = new Vector<Color3f>();
		
		for(PointLight light : Pipeline.lights) {
			Vector4f p = new Vector4f(light.getPosition());
			
			p.w = 1;
			
			pipe.modelviewMatrix.rightMultiply(p);
			
			lightSources.add(p);
			lightColors.add(light.getIntensity());
		}
	}

	public void vertex(Vector3f v, Color3f c, Vector3f n, Vector2f t_ignore, Vertex output)
	{
		Vector4f v2 = new Vector4f();
		Vector4f n2 = new Vector4f();
		
		// Position of vextex in eye coordinates
		v2.set(v.x, v.y, v.z, 1);
		modelview.rightMultiply(v2);
		
		// Normal in eye coordinates
		n2.set(n.x, n.y, n.z, 0);
		modelview.rightMultiply(n2);
		
		n2.normalize();
		
		// Color generated by contribution of all lights
		// Ambient contribution
		Color3f c2 = new Color3f(Pipeline.ambientIntensity*c.x, Pipeline.ambientIntensity*c.y, Pipeline.ambientIntensity*c.z);
		
		// For each light, get the contribution to this vertex
		for(PointLight light : Pipeline.lights) {
			Vector4f l = new Vector4f(light.getPosition());
			Color3f lc = light.getIntensity();
			
			// Vector from vertex to light source -- normalized
			l.sub(v2);
			l.normalize();
			
			float dot = l.dot(n2);

			// Diffuse contribution
			if(dot > 0) {
				c2.x += c.x*dot*lc.x;
				c2.y += c.y*dot*lc.y;
				c2.z += c.z*dot*lc.z;
			}
			
			// Half vector for specular lighting
			Vector4f h = new Vector4f(l);
			
			h.add(n2);
			h.normalize();
			
			dot = h.dot(l);
			
			// Specular contribution
			if(dot > 0) {
				dot = (float) Math.pow(dot, Pipeline.specularExponent);
				
				c2.x += dot*Pipeline.specularColor.x*lc.x;
				c2.y += dot*Pipeline.specularColor.y*lc.y;
				c2.z += dot*Pipeline.specularColor.z*lc.z;
			}
		}
		
		// Clamp rgb to [0,1]
		if(c2.x > 1) {
			c2.x = 1;
		}
		if(c2.y > 1) {
			c2.y = 1;
		}
		if(c2.z > 1) {
			c2.z = 1;
		}
		
		output.v.set(v.x, v.y, v.z, 1);
		m.rightMultiply(output.v);
		
		output.setAttrs(nAttr());
		output.attrs[0] = c2.x;
		output.attrs[1] = c2.y;
		output.attrs[2] = c2.z;
	}
	
	public void triangle(Vector3f[] v, Color3f[] c, Vector3f[] n, Vector2f[] t, Vertex[] output)
	{
		for (int k = 0; k < 3; k++) {
			vertex(v[k], c[k], n[k], t[k], output[k]);
		}
	}
}
